<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/post-controller.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/post-controller.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * Blog post pages
 *
 * @module controllers/post-controller
 */

const constants = require('../core/constants')
const forms = require('../core/forms')
const models = require('../core/models')
const cache = require('../core/cache')
const postService = require('../services/post-service')
const eventService = require('../services/event-service')
const securityService = require('../services/security-service')
const templating = require('./templating')

module.exports = {
  handleSaveComment,

  postMiddleware,

  posts,
  article,

  editPost,
  savePost,
  viewPost,
  deletePost,

  saveComment
}

async function postMiddleware (req, res, next) {
  if (req.params.postId &amp;&amp; req.params.postId !== 'create') {
    if (forms.isId(req.params.postId)) {
      res.locals.post = await postService.findPostById(req.params.postId)
      res.locals.event = res.locals.post.related('event')
      if (res.locals.event) {
        res.locals.latestEventAnnouncement = await postService.findLatestAnnouncement({
          eventId: res.locals.event.get('id')
        })
      }
    }

    if (res.locals.post) {
      res.locals.pageTitle = res.locals.post.get('title')
      res.locals.pageDescription = forms.markdownToText(res.locals.post.get('body'))
    } else {
      res.errorPage(404, 'Post not found')
      return
    }
  }

  next()
}

/**
 * Announcements listing
 */
async function posts (req, res) {
  // Fetch posts
  let specialPostType = forms.sanitizeString(req.query['special_post_type']) || null
  let eventId = forms.sanitizeString(req.query['event_id']) || undefined
  let currentPage = forms.isId(req.query.p) ? parseInt(req.query.p) : 1
  let posts = await postService.findPosts({
    specialPostType,
    eventId,
    page: currentPage
  })
  await posts.load(['event', 'entry'])
  let pageCount = await postService.findPosts({
    specialPostType,
    eventId,
    pageCount: true
  })

  // Determine title
  let title = 'Posts'
  if (specialPostType === constants.SPECIAL_POST_TYPE_ANNOUNCEMENT) {
    title = 'Announcements'
  }
  res.locals.pageTitle = title

  // Determine base URL for pagination
  let paginationBaseUrl = '/posts?'
  if (specialPostType) {
    paginationBaseUrl += '&amp;special_post_type=' + specialPostType
  }
  if (eventId) {
    paginationBaseUrl += '&amp;event_id=' + eventId
  }

  res.render('posts', {
    posts: posts.models,
    title,
    currentPage,
    pageCount,
    paginationBaseUrl
  })
}

/**
 * Articles
 */
async function article (req, res) {
  // postName context variable is used to add a relevant "create article" mod button
  res.locals.postName = forms.sanitizeString(req.params.name)
  res.locals.post = await postService.findPost({
    name: res.locals.postName,
    specialPostType: constants.SPECIAL_POST_TYPE_ARTICLE,
    allowDrafts: true
  })

  if (res.locals.post &amp;&amp; (postService.isPast(res.locals.post.get('published_at')) ||
      securityService.canUserRead(res.locals.user, res.locals.post, { allowMods: true }))) {
    res.locals.pageTitle = forms.capitalize(res.locals.post.get('title'))
    res.locals.pageDescription = forms.markdownToText(res.locals.post.get('body'))
    res.render('article')
  } else {
    res.errorPage(404)
  }
}

async function viewPost (req, res) {
  // Check permissions
  let post = res.locals.post
  if (postService.isPast(res.locals.post.get('published_at')) ||
      securityService.canUserRead(res.locals.user, post, { allowMods: true })) {
    let context = {
      sortedComments: await postService.findCommentsSortedForDisplay(post)
    }

    // Attach related entry/event
    if (post.get('event_id')) {
      if (post.related('event').id) {
        context.relatedEvent = post.related('event')
      }
      if (post.related('entry').id &amp;&amp; !post.get('special_post_type')) {
        context.relatedEntry = post.related('entry')
      }
    }

    res.render('post/view-post', context)
  } else {
    res.errorPage(403)
  }
}

async function editPost (req, res) {
  let createMode = !res.locals.post
  if (createMode || securityService.canUserWrite(res.locals.user, res.locals.post, { allowMods: true })) {
    if (createMode) {
      let post = new models.Post()
      if (forms.isId(req.query.eventId)) {
        post.set('event_id', req.query.eventId)
      }
      if (forms.isId(req.query.entryId)) {
        post.set('entry_id', req.query.entryId)
      }
      post.set('special_post_type', forms.sanitizeString(req.query['special_post_type']))
      post.set('title', forms.sanitizeString(req.query.title))

      // Check whether we're trying to create an existing article
      if (post.get('special_post_type') === constants.SPECIAL_POST_TYPE_ARTICLE &amp;&amp; post.get('name')) {
        post.trigger('titleChanged')
        let existingPost = await postService.findPost({
          name: post.get('name'),
          specialPostType: constants.SPECIAL_POST_TYPE_ARTICLE,
          allowDrafts: true
        })
        if (existingPost) {
          post = existingPost
        }
      }

      res.locals.post = post
    }

    // Fetch related event info
    let post = res.locals.post
    let context = {
      allEvents: (await eventService.findEvents()).models
    }
    if (post.get('event_id')) {
      context.relatedEvent = await eventService.findEventById(post.get('event_id'))
    }
    context.specialPostType = post.get('special_post_type')

    res.render('post/edit-post', context)
  } else {
    res.errorPage(403)
  }
}

async function savePost (req, res) {
  let post = res.locals.post

  // Check permissions
  if ((post &amp;&amp; securityService.canUserWrite(res.locals.user, post, { allowMods: true })) ||
      !(post &amp;&amp; res.locals.user)) {
    let redirectToView = false
    let {fields} = await req.parseForm()
    let title = forms.sanitizeString(fields.title)
    let errorMessage = null
    if (!title) {
      errorMessage = 'Title is mandatory'
    }

    if (!errorMessage) {
      // Create new post if needed
      if (!post) {
        post = await postService.createPost(res.locals.user)
        let specialPostType = req.query['special_post_type']
        if (specialPostType) {
          validateSpecialPostType(specialPostType, res.locals.user)
          post.set('special_post_type', specialPostType)
        }
      }

      // Fill post from form info
      post.set('title', forms.sanitizeString(fields.title))
      post.set('body', forms.sanitizeMarkdown(fields.body))
      if (forms.isId(fields['event-id'])) {
        post.set('event_id', fields['event-id'])
        if (!post.get('special_post_type')) {
          if (post.hasChanged('event_id')) {
            let relatedEntry = await eventService.findUserEntryForEvent(
              res.locals.user, post.get('event_id'))
            post.set('entry_id', relatedEntry ? relatedEntry.get('id') : null)
          }
        } else {
          post.set('entry_id', null)
        }
      } else {
        post.set('event_id', null)
        post.set('entry_id', null)
      }
      if (post.get('special_post_type') === constants.SPECIAL_POST_TYPE_ARTICLE) {
        post.set('name', forms.slug(fields.name || fields.title))
      }

      // Publication &amp; redirection strategy
      redirectToView = true
      if (fields.publish) {
        post.set('published_at', new Date())
      } else if (fields.unpublish) {
        post.set('published_at', null)
        redirectToView = false
      } else if (fields['save-custom']) {
        post.set('published_at', forms.parseDateTime(fields['published-at']))
      }

      // Save
      await post.save()
      cache.user(res.locals.user).del('latestPostsCollection')
    }

    // Render
    if (redirectToView) {
      res.redirect(templating.buildUrl(post, 'post')) // TODO move buildUrl to routing-service
    } else {
      res.render('post/edit-post', {
        post,
        errorMessage
      })
    }
  } else {
    res.errorPage(403)
  }
}

function validateSpecialPostType (specialPostType, user) {
  if (constants.SPECIAL_POST_TYPES.indexOf(specialPostType) === -1) {
    throw new Error('invalid special post type: ' + specialPostType)
  }
  if (specialPostType === 'announcement' &amp;&amp; !securityService.isMod(user)) {
    throw new Error('non-mod ' + user.get('name') + ' attempted to create an announcement')
  }
}

async function deletePost (req, res) {
  await res.locals.post.destroy()
  cache.user(res.locals.user).del('latestPostsCollection')
  res.redirect('/')
}

/**
 * Save or delete a comment
 */
async function saveComment (req, res) {
  let {fields} = await req.parseForm()
  let redirectUrl = await handleSaveComment(fields, res.locals.user, res.locals.post, templating.buildUrl(res.locals.post, 'post'))
  res.redirect(redirectUrl)
}

/**
 * Handler for handling the comment saving form.
 * Reusable between all controllers of models supporting comments.
 * @param {object} fields The parsed form fields
 * @param {User} user The current user
 * @param {Post|Entry} node The current node model
 * @param {string} baseUrl The view URL for the current node
 * @return {string} A URL to redirect to
 */
async function handleSaveComment (fields, currentUser, currentNode, baseUrl) {
  let redirectUrl = baseUrl

  // Find or create comment
  let comment = null
  let isNewComment = false
  if (fields.id) {
    if (forms.isId(fields.id)) {
      comment = await postService.findCommentById(fields.id)
    } else {
      return redirectUrl
    }
  } else {
    isNewComment = true
    comment = await postService.createComment(currentUser, currentNode)
  }

  if (securityService.canUserWrite(currentUser, comment, { allowMods: true })) {
    if (fields.delete) {
      // Delete comment
      await comment.destroy()
    } else {
      // Update comment
      comment.set('body', forms.sanitizeMarkdown(fields.body))
      await eventService.refreshCommentScore(comment)
      await comment.save()

      // Refresh feedback score on both the giver &amp; receiver entries
      if (comment.get('node_type') === 'entry') {
        let currentEntry = currentNode
        let userEntry = await eventService.findUserEntryForEvent(
          currentUser, currentEntry.get('event_id'))

        // (No need to await, it's okay if the score is a bit late)
        // XXXXXXXXXXXXX
        await eventService.refreshEntryScore(currentEntry)
        if (userEntry) {
          await eventService.refreshEntryScore(userEntry)
        }
      }

      // we need to update the comment feed and unread notifications of users associated with the post/entry
      let node = comment.related('node')
      let userRoles = node.related('userRoles')
      userRoles.forEach(function (userRole) {
        let userCache = cache.user(userRole.get('user_name'))
        userCache.del('toUserCollection')
        userCache.del('unreadNotifications')
      })

      // and also any users @mentioned in the comment
      let body = comment.get('body')
      body.split(' ').forEach(function (word) {
        if (word.length > 0 &amp;&amp; word[0] === '@') {
          let userCache = cache.user(word.slice(1))
          userCache.del('toUserCollection')
          userCache.del('unreadNotifications')
        }
      })

      redirectUrl += templating.buildUrl(comment, 'comment')
    }
    cache.user(currentUser.get('name')).del('byUserCollection')

    // Refresh node comment count
    if (fields.delete || isNewComment) {
      await postService.refreshCommentCount(currentNode)
    }
  }

  return redirectUrl
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-controllers.html">controllers</a></li><li><a href="module-controllers_api-controller.html">controllers/api-controller</a></li><li><a href="module-controllers_entry-controller.html">controllers/entry-controller</a></li><li><a href="module-controllers_event-controller.html">controllers/event-controller</a></li><li><a href="module-controllers_main-controller.html">controllers/main-controller</a></li><li><a href="module-controllers_post-controller.html">controllers/post-controller</a></li><li><a href="module-controllers_templating.html">controllers/templating</a></li><li><a href="module-controllers_user-controller.html">controllers/user-controller</a></li><li><a href="module-core_cache.html">core/cache</a></li><li><a href="module-core_constants.html">core/constants</a></li><li><a href="module-core_db.html">core/db</a></li><li><a href="module-core_file-storage.html">core/file-storage</a></li><li><a href="module-core_forms.html">core/forms</a></li><li><a href="module-core_log.html">core/log</a></li><li><a href="module-core_middleware.html">core/middleware</a></li><li><a href="module-core_models.html">core/models</a></li><li><a href="module-server.html">server</a></li><li><a href="module-services_event-service.html">services/event-service</a></li><li><a href="module-services_invite-service.html">services/invite-service</a></li><li><a href="module-services_post-service.html">services/post-service</a></li><li><a href="module-services_security-service.html">services/security-service</a></li><li><a href="module-services_session-service.html">services/session-service</a></li><li><a href="module-services_setting-service.html">services/setting-service</a></li><li><a href="module-services_user-service.html">services/user-service</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Aug 08 2017 14:04:54 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
