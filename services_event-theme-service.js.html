<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/event-theme-service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/event-theme-service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * Service for managing theme voting.
 *
 * @module services/event-theme-service
 */

const models = require('../core/models')
const constants = require('../core/constants')
const log = require('../core/log')
const forms = require('../core/forms')

module.exports = {
  findThemeIdeasByUser,
  saveThemeIdeas,

  findThemeVotesHistory,
  findThemesToVoteOn,
  saveVote,

  findBestThemes
}

/**
 * Saves the theme ideas of an user for an event
 * @param user {User} user model
 * @param event {Event} event model
 * @param ideas {array(object)} An array of exactly 3 ideas (all fields optional): [{label, id}]
 */
async function findThemeIdeasByUser (user, event) {
  return models.Theme.where({
    user_id: user.get('id'),
    event_id: event.get('id')
  }).fetchAll()
}

/**
 * Saves the theme ideas of an user for an event
 * @param user {User} user model
 * @param event {Event} event model
 * @param ideas {array(object)} An array of exactly 3 ideas: [{title, id}]. Not filling the title
 * deletes the idea, not filling the ID creates one instead of updating it.
 */
async function saveThemeIdeas (user, event, ideas) {
  if (ideas.length !== 3) {
    throw new Error('there must be information for exactly 3 theme ideas')
  }

  let tasks = []

  // Run through all existing themes for that event/user combination
  let existingThemes = await findThemeIdeasByUser(user, event)
  let handledThemes = []
  for (let idea of ideas) {
    if (idea.id) {
      let existingTheme = existingThemes.findWhere({'id': parseInt(idea.id)})
      // We can only delete/update themes if they're active or cancelled because they're duplicates
      if (existingTheme &amp;&amp; (existingTheme.get('status') === constants.THEME_STATUS_ACTIVE ||
          existingTheme.get('status') === constants.THEME_STATUS_DUPLICATE)) {
        if (idea.title) {
          // Update existing theme if needed
          if (idea.title !== existingTheme.get('title')) {
            existingTheme.set({
              title: idea.title,
              status: constants.THEME_STATUS_ACTIVE,
              score: 0,
              notes: 0,
              reports: 0
            })
            await handleDuplicates(existingTheme)
            tasks.push(existingTheme.save())
          }
        } else {
          // Delete existing theme
          tasks.push(existingTheme.destroy())
        }
        handledThemes.push(existingTheme)
      } else {
        log.warn('Invalid theme ID for user ' + user.get('name') + ': ' + idea.id)
        idea.id = null
      }
    }

    if (!idea.id &amp;&amp; idea.title) {
      // Create theme
      let theme = new models.Theme({
        user_id: user.get('id'),
        event_id: event.get('id'),
        title: idea.title,
        status: constants.THEME_STATUS_ACTIVE
      })
      await handleDuplicates(theme)
      tasks.push(theme.save())
    }
  }

  // Destroy any theme not among the ideas
  let missingThemes = existingThemes.difference(handledThemes)
  if (missingThemes.length > 0) {
    log.warn('Theme ID were not given among the parameters for user ' + user.get('name') + ':')
    for (let missingTheme of missingThemes) {
      log.warn(' - ' + missingTheme.get('id'))
      tasks.push(missingTheme.destroy())
    }
  }

  await Promise.all(tasks)
}

/**
 * Sets the theme status to "duplicate" if another theme is identical
 */
async function handleDuplicates (theme) {
  theme.set('slug', forms.slug(theme.get('title')))

  let query = models.Theme.where({
    slug: theme.get('slug'),
    event_id: theme.get('event_id')
  })
  if (theme.get('id')) {
    query = query.where('id', '&lt;>', theme.get('id'))
  }
  if ((await query.fetch()) !== null) {
    theme.set('status', constants.THEME_STATUS_DUPLICATE)
  }
}

/**
 * Returns the 30 latest votes by the user
 * @param user {User} user model
 * @param event {Event} event model
 */
async function findThemeVotesHistory (user, event) {
  return models.ThemeVote.where({
    event_id: event.get('id'),
    user_id: user.get('id')
  })
      .orderBy('id', 'DESC')
      .fetchPage({
        pageSize: 30,
        withRelated: ['theme']
      })
}

/**
 * Returns a page of 10 themes that a user can vote on
 * @param user {User} (optional) user model
 * @param event {Event} event model
 */
async function findThemesToVoteOn (user, event) {
  let query = models.Theme
  if (user) {
    query = query.query(function (qb) {
      qb.leftOuterJoin('theme_vote', function () {
        this.on('theme.id', '=', 'theme_vote.theme_id')
        this.andOn('theme_vote.user_id', '=', user.get('id'))
      })
    })
        .where({
          status: constants.THEME_STATUS_ACTIVE,
          'theme.event_id': event.get('id'),
          'theme_vote.user_id': null
        })
        .where('theme.user_id', '&lt;>', user.get('id'))
  } else {
    query = query.where('event_id', event.get('id'))
  }
  return query.orderBy('notes', 'DESC')
      .fetchPage({ pageSize: 10 })
}

/**
 * Saves a theme vote
 * @param user {User} user model
 * @param event {Event} event model
 * @param themeId {integer}
 * @param score {integer}
 */
async function saveVote (user, event, themeId, score) {
  // TODO Refine theme statuses
  if (event.get('status_theme') === 'on' &amp;&amp; [-1, 1].indexOf(score) !== -1) {
    let theme = await models.Theme.where('id', themeId).fetch()
    let vote = await models.ThemeVote.where({
      user_id: user.get('id'),
      event_id: event.get('id'),
      theme_id: themeId
    }).fetch()

    if (vote) {
      theme.set('score', theme.get('score') + score - (vote.get('score') || 0))
      vote.set('score', score)
    } else {
      theme.set({
        'score': theme.get('score') + score,
        'notes': theme.get('notes') + 1
      })
      vote = new models.ThemeVote({
        theme_id: themeId,
        user_id: user.get('id'),
        event_id: event.get('id'),
        score: score
      })
    }

    await Promise.all([theme.save(), vote.save()])
  }
}

async function findBestThemes (event, options) {
  let query = models.Theme.where({
    event_id: event.get('id')
  }).orderBy('score', 'DESC')
  if (options.fetchAll) {
    return query.fetchAll()
  } else {
    return query.fetchPage({ pageSize: 10 })
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-controllers.html">controllers</a></li><li><a href="module-controllers_api-controller.html">controllers/api-controller</a></li><li><a href="module-controllers_entry-controller.html">controllers/entry-controller</a></li><li><a href="module-controllers_event-controller.html">controllers/event-controller</a></li><li><a href="module-controllers_main-controller.html">controllers/main-controller</a></li><li><a href="module-controllers_post-controller.html">controllers/post-controller</a></li><li><a href="module-controllers_templating.html">controllers/templating</a></li><li><a href="module-controllers_user-controller.html">controllers/user-controller</a></li><li><a href="module-core_cache.html">core/cache</a></li><li><a href="module-core_constants.html">core/constants</a></li><li><a href="module-core_db.html">core/db</a></li><li><a href="module-core_file-storage.html">core/file-storage</a></li><li><a href="module-core_forms.html">core/forms</a></li><li><a href="module-core_log.html">core/log</a></li><li><a href="module-core_middleware.html">core/middleware</a></li><li><a href="module-core_models.html">core/models</a></li><li><a href="module-server.html">server</a></li><li><a href="module-services_event-service.html">services/event-service</a></li><li><a href="module-services_event-theme-service.html">services/event-theme-service</a></li><li><a href="module-services_invite-service.html">services/invite-service</a></li><li><a href="module-services_post-service.html">services/post-service</a></li><li><a href="module-services_security-service.html">services/security-service</a></li><li><a href="module-services_session-service.html">services/session-service</a></li><li><a href="module-services_setting-service.html">services/setting-service</a></li><li><a href="module-services_user-service.html">services/user-service</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Aug 18 2017 11:59:09 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
